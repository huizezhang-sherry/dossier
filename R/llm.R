#' Extract decisions from PDF inputs via LLM
#'
#' The function writes a markdown file at the `file` location with the decisions
#' extracted from the PDF inputs via the LLM. The decisions are  formatted as a
#' JSON block. See the LLM prompt file
#' `system.file("prompt.md", package = "dossier") |> readLines()` for more
#' details. To setup the authentication for the LLM, please refer to the
#' `ellmer` package.
#'
#'
#' @param prompt_file A single string containing the prompt
#' @param pdf A single string specifying the path to a PDF file
#' @param file A single string specifying where to save the output. By default,
#' it saves a markdown file with the same name as the PDF file in the same directory.
#' @param llm_model One of `"claude"` or `"gemini"` for processing pdf documents. Default to `gemini`
#' @param ... other arguments supplied to the LLM chat function, such as `seed`, `temperature`, etc.
#'
#' @returns
#' Writes output to the specified file.
#'
#' @export
#' @rdname llm
#' @seealso [clean_md]
extract_decisions <- function(prompt_file, pdf, file = NULL, ..., llm_model = "gemini"){
  args <- rlang::list2(...)

  prompt <- ellmer::interpolate_file(prompt_file)

  if (llm_model == "claude") {
    chat <- do.call("chat_anthropic", args = list(params = args))
  } else if (llm_model == "gemini") {
    chat <- do.call("chat_google_gemini", args = list(params = args))
  } else {
    stop("Unsupported LLM model. Please use 'Claude' or 'Gemini'.")
  }

  if (is.null(file)) {
    file <- paste0(tools::file_path_sans_ext(pdf), ".md")
  }

  writeLines(
    chat$chat(prompt, ellmer::content_pdf_file(pdf)),
    con = file
  )

}

#' Deprecated functions
#' @description
#' `r lifecycle::badge("deprecated")`
#' * [summarize_pdf()]/ [summarise_pdf()] are renamed to [extract_decisions()].
#' @keywords internal
#' @rdname deprecated
#' @export
summarize_pdf <- function(...) {
  lifecycle::deprecate_warn("0.0.1", "summarize_pdf()", "extract_decisions()")
  extract_decisions(...)
}

#' @rdname deprecated
#' @export
summarize_pdf <- function(...) {
  lifecycle::deprecate_warn("0.0.1", "summarize_pdf()", "extract_decisions()")
  extract_decisions(...)
}


#' Create the decision table object
#'
#' The function takes an input of a character string (path to the markdown file
#' generated by [extract_decisions()]) or a data frame/tibble and returns a
#' decision table object
#' @param x The input to be casted into a decision table object
#'
#' @returns
#' A tibble of class decision_tbl
#'
#' @export
#' @rdname class
#' @examples
#' raw_df <- read.csv(system.file("papers.csv", package = "dossier")) |> tibble::as_tibble()
#' as_decision_tbl(raw_df)
#' as_decision_tbl(system.file("braga.md", package = "dossier"))
as_decision_tbl <- function(x){
  UseMethod("as_decision_tbl")
}

#' @export
#' @rdname class
as_decision_tbl.character <- function(x){
  if (!file.exists(x)) {
    cli::cli_abort(c("The file {.file {x}} does not exist."))
  }

  if (tools::file_ext(x) != "md") {
    cli::cli_abort(c("The file {.file {x}} is not a markdown file. Please use the input
                     from the LLM extraction function {.fn extract_decisions}."))
  }

  lines <- readLines(x)
  start <- which(grepl("^```json", lines))
  end <- which(grepl("^```", lines))[-1]
  json_lines <- lines[(start + 1):(end[1] - 1)]
  json_text <- paste(json_lines, collapse = "\n")

  # remove no-ASCII, newlines before letters, and replace NA with "NA"
  json_text <- gsub("[^\x01-\x7F]", "", json_text)
  json_text <- gsub("\n(?=[A-Za-z(0-9])", "", json_text, perl = TRUE)
  json_text <- gsub("NA,", '"NA",', json_text)

  res <- jsonlite::fromJSON(json_text)$decisions |> tibble::as_tibble()
  res <- tibble::tibble(paper = tools::file_path_sans_ext(basename(x))) |>
    dplyr::bind_cols(res)

  res <- new_decision_tbl(res, form = "std")
  res
}

#' @export
#' @rdname class
as_decision_tbl.tbl_df <- function(x){

  new_decision_tbl(x, form = "std")
}


new_decision_tbl <- function(x, ...){

  args <- rlang::list2(...)

  res <- tibble::new_tibble(x, !!!args)
  class(res) <- c("decision_tbl", class(x))
  res
}


verify_df_std <- function(x){

  verify_decision_tbl(x)
  if (attr(x, "form") != "std"){
    cli::cli_abort("A {.field std} format of the decision table is required.")
  }
}

verify_df_var_type_wide <- function(x){

  verify_decision_tbl(x)
  if (attr(x, "form") != "var_type_wide"){
    cli::cli_abort("A {.field wide} format of the decision table is required.
                   Consider using {.fn pivot_var_type_wider} to reshape the decision table.")
  }
}


verify_df_tbl_wide <- function(x){

  verify_decision_tbl(x)
  if (attr(x, "form") != "tbl_wide"){
    cli::cli_abort("A {.field wide} format of the decision table is required.
                   Consider using {.fn pivot_decision_tbl_wider} to reshape the decision table.")
  }
}



verify_df_long <- function(x){

  verify_decision_tbl(x)
  if (attr(x, "form") != "long"){
    cli::cli_abort("A {.field long} format of the decision table is required.
                   Consider using {.fn pivot_decision_tbl_longer} to reshape the decision table.")
  }
}


verify_decision_tbl <- function(df){
  if (!inherits(df, "decision_tbl")){
    cli::cli_abort("An {.field decision_tbl} object is required as the input, please check.")
  }
}
